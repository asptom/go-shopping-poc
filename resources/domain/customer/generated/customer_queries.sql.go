// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customer_queries.sql

package customer

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCustomer = `-- name: AddCustomer :one

INSERT INTO customers.Customer (
    customerId,
    username,
    firstName,
    lastName,
    email,
    phone
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING customerId, username, firstName, lastName, email, phone
`

type AddCustomerParams struct {
	Customerid pgtype.UUID `json:"customerid"`
	Username   string      `json:"username"`
	Firstname  pgtype.Text `json:"firstname"`
	Lastname   pgtype.Text `json:"lastname"`
	Email      pgtype.Text `json:"email"`
	Phone      pgtype.Text `json:"phone"`
}

type AddCustomerRow struct {
	Customerid pgtype.UUID `json:"customerid"`
	Username   string      `json:"username"`
	Firstname  pgtype.Text `json:"firstname"`
	Lastname   pgtype.Text `json:"lastname"`
	Email      pgtype.Text `json:"email"`
	Phone      pgtype.Text `json:"phone"`
}

func (q *Queries) AddCustomer(ctx context.Context, arg AddCustomerParams) (AddCustomerRow, error) {
	row := q.db.QueryRow(ctx, addCustomer,
		arg.Customerid,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.Phone,
	)
	var i AddCustomerRow
	err := row.Scan(
		&i.Customerid,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.Phone,
	)
	return i, err
}

const addCustomerAddress = `-- name: AddCustomerAddress :one

INSERT INTO customers.Address (
    id,
    customerId,
    addressType,
    firstName,
    lastName,
    address_1,
    address_2,
    city,
    state,
    zip,
    isDefault
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id
`

type AddCustomerAddressParams struct {
	ID          int64       `json:"id"`
	Customerid  pgtype.UUID `json:"customerid"`
	Addresstype string      `json:"addresstype"`
	Firstname   pgtype.Text `json:"firstname"`
	Lastname    pgtype.Text `json:"lastname"`
	Address1    pgtype.Text `json:"address_1"`
	Address2    pgtype.Text `json:"address_2"`
	City        pgtype.Text `json:"city"`
	State       pgtype.Text `json:"state"`
	Zip         pgtype.Text `json:"zip"`
	Isdefault   pgtype.Bool `json:"isdefault"`
}

func (q *Queries) AddCustomerAddress(ctx context.Context, arg AddCustomerAddressParams) (int64, error) {
	row := q.db.QueryRow(ctx, addCustomerAddress,
		arg.ID,
		arg.Customerid,
		arg.Addresstype,
		arg.Firstname,
		arg.Lastname,
		arg.Address1,
		arg.Address2,
		arg.City,
		arg.State,
		arg.Zip,
		arg.Isdefault,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addCustomerCreditCard = `-- name: AddCustomerCreditCard :one

INSERT INTO customers.CreditCard (
    id,
    customerId,
    cardType,
    cardNumber,
    cardHolderName,
    cardExpires,
    cardCVV,
    isDefault
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id
`

type AddCustomerCreditCardParams struct {
	ID             int64       `json:"id"`
	Customerid     pgtype.UUID `json:"customerid"`
	Cardtype       pgtype.Text `json:"cardtype"`
	Cardnumber     pgtype.Text `json:"cardnumber"`
	Cardholdername pgtype.Text `json:"cardholdername"`
	Cardexpires    pgtype.Text `json:"cardexpires"`
	Cardcvv        pgtype.Text `json:"cardcvv"`
	Isdefault      pgtype.Bool `json:"isdefault"`
}

func (q *Queries) AddCustomerCreditCard(ctx context.Context, arg AddCustomerCreditCardParams) (int64, error) {
	row := q.db.QueryRow(ctx, addCustomerCreditCard,
		arg.ID,
		arg.Customerid,
		arg.Cardtype,
		arg.Cardnumber,
		arg.Cardholdername,
		arg.Cardexpires,
		arg.Cardcvv,
		arg.Isdefault,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addCustomerStatus = `-- name: AddCustomerStatus :one

INSERT INTO customers.CustomerStatus (
    id,
    customerId,
    customerStatus,
    statusDateTime
) VALUES (
  $1, $2, $3, NOW()
)
RETURNING id
`

type AddCustomerStatusParams struct {
	ID             int64       `json:"id"`
	Customerid     pgtype.UUID `json:"customerid"`
	Customerstatus string      `json:"customerstatus"`
}

func (q *Queries) AddCustomerStatus(ctx context.Context, arg AddCustomerStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, addCustomerStatus, arg.ID, arg.Customerid, arg.Customerstatus)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT customerid, username, email, firstname, lastname, phone FROM customers.Customer
WHERE customerId = $1 LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, customerid pgtype.UUID) (CustomersCustomer, error) {
	row := q.db.QueryRow(ctx, getCustomer, customerid)
	var i CustomersCustomer
	err := row.Scan(
		&i.Customerid,
		&i.Username,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
	)
	return i, err
}

const getCustomerAddresses = `-- name: GetCustomerAddresses :many
SELECT id, customerid, addresstype, firstname, lastname, address_1, address_2, city, state, zip, isdefault FROM customers.Address
WHERE customerId = $1
ORDER BY isDefault DESC
`

func (q *Queries) GetCustomerAddresses(ctx context.Context, customerid pgtype.UUID) ([]CustomersAddress, error) {
	rows, err := q.db.Query(ctx, getCustomerAddresses, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersAddress
	for rows.Next() {
		var i CustomersAddress
		if err := rows.Scan(
			&i.ID,
			&i.Customerid,
			&i.Addresstype,
			&i.Firstname,
			&i.Lastname,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.State,
			&i.Zip,
			&i.Isdefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerBillingAddresses = `-- name: GetCustomerBillingAddresses :many
SELECT id, customerid, addresstype, firstname, lastname, address_1, address_2, city, state, zip, isdefault FROM customers.Address
WHERE customerId = $1 and addressType = 'billing'
ORDER BY isDefault DESC
`

func (q *Queries) GetCustomerBillingAddresses(ctx context.Context, customerid pgtype.UUID) ([]CustomersAddress, error) {
	rows, err := q.db.Query(ctx, getCustomerBillingAddresses, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersAddress
	for rows.Next() {
		var i CustomersAddress
		if err := rows.Scan(
			&i.ID,
			&i.Customerid,
			&i.Addresstype,
			&i.Firstname,
			&i.Lastname,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.State,
			&i.Zip,
			&i.Isdefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByUsername = `-- name: GetCustomerByUsername :one
SELECT customerid, username, email, firstname, lastname, phone FROM customers.Customer
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetCustomerByUsername(ctx context.Context, username string) (CustomersCustomer, error) {
	row := q.db.QueryRow(ctx, getCustomerByUsername, username)
	var i CustomersCustomer
	err := row.Scan(
		&i.Customerid,
		&i.Username,
		&i.Email,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
	)
	return i, err
}

const getCustomerCreditCards = `-- name: GetCustomerCreditCards :many
SELECT id, customerid, cardtype, cardnumber, cardholdername, cardexpires, cardcvv, isdefault FROM customers.CreditCard
WHERE customerId = $1
ORDER BY isDefault DESC
`

func (q *Queries) GetCustomerCreditCards(ctx context.Context, customerid pgtype.UUID) ([]CustomersCreditcard, error) {
	rows, err := q.db.Query(ctx, getCustomerCreditCards, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersCreditcard
	for rows.Next() {
		var i CustomersCreditcard
		if err := rows.Scan(
			&i.ID,
			&i.Customerid,
			&i.Cardtype,
			&i.Cardnumber,
			&i.Cardholdername,
			&i.Cardexpires,
			&i.Cardcvv,
			&i.Isdefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerCurrentStatus = `-- name: GetCustomerCurrentStatus :one
SELECT id, customerid, customerstatus, statusdatetime FROM customers.CustomerStatus
WHERE customerId = $1
ORDER BY statusDateTime DESC
LIMIT 1
`

func (q *Queries) GetCustomerCurrentStatus(ctx context.Context, customerid pgtype.UUID) (CustomersCustomerstatus, error) {
	row := q.db.QueryRow(ctx, getCustomerCurrentStatus, customerid)
	var i CustomersCustomerstatus
	err := row.Scan(
		&i.ID,
		&i.Customerid,
		&i.Customerstatus,
		&i.Statusdatetime,
	)
	return i, err
}

const getCustomerShippingAddresses = `-- name: GetCustomerShippingAddresses :many
SELECT id, customerid, addresstype, firstname, lastname, address_1, address_2, city, state, zip, isdefault FROM customers.Address
WHERE customerId = $1 and addressType = 'shipping'
ORDER BY isDefault DESC
`

func (q *Queries) GetCustomerShippingAddresses(ctx context.Context, customerid pgtype.UUID) ([]CustomersAddress, error) {
	rows, err := q.db.Query(ctx, getCustomerShippingAddresses, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersAddress
	for rows.Next() {
		var i CustomersAddress
		if err := rows.Scan(
			&i.ID,
			&i.Customerid,
			&i.Addresstype,
			&i.Firstname,
			&i.Lastname,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.State,
			&i.Zip,
			&i.Isdefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerStatuses = `-- name: GetCustomerStatuses :many
SELECT id, customerid, customerstatus, statusdatetime FROM customers.CustomerStatus
WHERE customerId = $1
ORDER BY statusDateTime DESC
`

func (q *Queries) GetCustomerStatuses(ctx context.Context, customerid pgtype.UUID) ([]CustomersCustomerstatus, error) {
	rows, err := q.db.Query(ctx, getCustomerStatuses, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersCustomerstatus
	for rows.Next() {
		var i CustomersCustomerstatus
		if err := rows.Scan(
			&i.ID,
			&i.Customerid,
			&i.Customerstatus,
			&i.Statusdatetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomers = `-- name: GetCustomers :many
SELECT customerid, username, email, firstname, lastname, phone FROM customers.Customer
ORDER BY username
`

func (q *Queries) GetCustomers(ctx context.Context) ([]CustomersCustomer, error) {
	rows, err := q.db.Query(ctx, getCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomersCustomer
	for rows.Next() {
		var i CustomersCustomer
		if err := rows.Scan(
			&i.Customerid,
			&i.Username,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
