// Package product provides comprehensive unit tests for the product repository.
//
// This test suite covers all repository operations including CRUD operations,
// transaction handling, error scenarios, and bulk operations. Tests use
// mocked database interfaces to ensure isolation and reliability.
package product

import (
	"context"
	"database/sql"
	"errors"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jmoiron/sqlx"
)

// mockDatabase implements the database.Database interface for testing
// NOTE: This mock needs to be updated to work with the new direct sqlx.DB approach
// For now, tests are skipped until sqlmock integration is implemented
type mockDatabase struct {
	shouldFail  bool
	queryRows   *sql.Rows
	execResult  sql.Result
	beginTxFunc func(ctx context.Context, opts *sql.TxOptions) (database.Tx, error)
}

func (m *mockDatabase) Connect(ctx context.Context) error {
	if m.shouldFail {
		return errors.New("connection failed")
	}
	return nil
}

func (m *mockDatabase) Close() error {
	return nil
}

func (m *mockDatabase) Ping(ctx context.Context) error {
	if m.shouldFail {
		return errors.New("ping failed")
	}
	return nil
}

func (m *mockDatabase) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	if m.shouldFail {
		return nil, errors.New("query failed")
	}
	return m.queryRows, nil
}

func (m *mockDatabase) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
	// For testing purposes, we'll skip the actual database calls
	// and focus on testing the repository logic and validation
	return nil
}

func (m *mockDatabase) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	if m.shouldFail {
		return nil, errors.New("exec failed")
	}
	return m.execResult, nil
}

func (m *mockDatabase) BeginTx(ctx context.Context, opts *sql.TxOptions) (database.Tx, error) {
	if m.beginTxFunc != nil {
		return m.beginTxFunc(ctx, opts)
	}
	if m.shouldFail {
		return nil, errors.New("begin tx failed")
	}
	return &mockTx{shouldFail: m.shouldFail, execResult: m.execResult}, nil
}

func (m *mockDatabase) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
	if m.shouldFail {
		return errors.New("get failed")
	}
	return nil
}

func (m *mockDatabase) SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
	if m.shouldFail {
		return errors.New("select failed")
	}
	return nil
}

func (m *mockDatabase) Stats() sql.DBStats {
	return sql.DBStats{}
}

// mockTx implements the database.Tx interface for testing
type mockTx struct {
	shouldFail     bool
	queryRows      *sql.Rows
	execResult     sql.Result
	rollbackCalled bool
	commitCalled   bool
}

func (m *mockTx) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	if m.shouldFail {
		return nil, errors.New("tx query failed")
	}
	return m.queryRows, nil
}

func (m *mockTx) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
	return nil
}

func (m *mockTx) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	if m.shouldFail {
		return nil, errors.New("tx exec failed")
	}
	return m.execResult, nil
}

func (m *mockTx) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	return m.Exec(ctx, query, args...)
}

func (m *mockTx) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) {
	if m.shouldFail {
		return nil, errors.New("named exec failed")
	}
	return m.execResult, nil
}

func (m *mockTx) Commit() error {
	if m.shouldFail {
		return errors.New("commit failed")
	}
	m.commitCalled = true
	return nil
}

func (m *mockTx) Rollback() error {
	if m.shouldFail {
		return errors.New("rollback failed")
	}
	m.rollbackCalled = true
	return nil
}

// mockResult implements sql.Result for testing
type mockResult struct {
	rowsAffected int64
	lastInsertID int64
}

func (m *mockResult) RowsAffected() (int64, error) {
	return m.rowsAffected, nil
}

func (m *mockResult) LastInsertId() (int64, error) {
	return m.lastInsertID, nil
}

func TestNewProductRepository(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	if repo == nil {
		t.Fatal("NewProductRepository returned nil")
	}

	// Verify the repository has the correct database reference
	productRepo, ok := repo.(*productRepository)
	if !ok {
		t.Fatal("NewProductRepository did not return *productRepository")
	}
	if productRepo.db != mockDB {
		t.Error("Repository database reference not set correctly")
	}
}

func TestInsertProduct_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	product := &Product{
		ID:           123,
		Name:         "Test Product",
		Description:  "Test Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
		Currency:     "USD",
		InStock:      true,
		Category:     "Test Category",
		Brand:        "Test Brand",
	}

	err := repo.InsertProduct(context.Background(), product)
	if err != nil {
		t.Fatalf("InsertProduct failed: %v", err)
	}
}

func TestInsertProduct_ValidationError(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	// Product with empty name should fail validation
	product := &Product{
		ID:           123,
		Description:  "Test Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
	}

	err := repo.InsertProduct(context.Background(), product)
	if err == nil {
		t.Fatal("InsertProduct should have failed validation")
	}
	if !strings.Contains(err.Error(), "product name is required") {
		t.Errorf("Expected validation error containing 'product name is required', got: %v", err)
	}
}

func TestInsertProduct_DatabaseError(t *testing.T) {
	mockDB := &mockDatabase{
		shouldFail: true,
	}
	repo := NewProductRepository(mockDB)

	product := &Product{
		ID:           123,
		Name:         "Test Product",
		Description:  "Test Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
		Currency:     "USD",
		InStock:      true,
		Category:     "Test Category",
		Brand:        "Test Brand",
	}

	err := repo.InsertProduct(context.Background(), product)
	if err == nil {
		t.Fatal("InsertProduct should have failed due to database error")
	}
	if !errors.Is(err, ErrTransactionFailed) {
		t.Errorf("Expected transaction failed error, got: %v", err)
	}
}

func TestGetProductByID_InvalidID(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	_, err := repo.GetProductByID(context.Background(), -1)
	if err == nil {
		t.Fatal("GetProductByID should have failed with invalid ID")
	}
	if !errors.Is(err, ErrInvalidProductID) {
		t.Errorf("Expected invalid product ID error, got: %v", err)
	}
}

func TestUpdateProduct_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	product := &Product{
		ID:           123,
		Name:         "Updated Product",
		Description:  "Updated Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
		Currency:     "USD",
		InStock:      true,
		Category:     "Test Category",
		Brand:        "Test Brand",
	}

	err := repo.UpdateProduct(context.Background(), product)
	if err != nil {
		t.Fatalf("UpdateProduct failed: %v", err)
	}
}

func TestUpdateProduct_NotFound(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 0},
	}
	repo := NewProductRepository(mockDB)

	product := &Product{
		ID:           123,
		Name:         "Updated Product",
		Description:  "Updated Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
		Currency:     "USD",
		InStock:      true,
		Category:     "Test Category",
		Brand:        "Test Brand",
	}

	err := repo.UpdateProduct(context.Background(), product)
	if err == nil {
		t.Fatal("UpdateProduct should have failed for non-existent product")
	}
	if !errors.Is(err, ErrProductNotFound) {
		t.Errorf("Expected product not found error, got: %v", err)
	}
}

func TestDeleteProduct_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	err := repo.DeleteProduct(context.Background(), 123)
	if err != nil {
		t.Fatalf("DeleteProduct failed: %v", err)
	}
}

func TestDeleteProduct_NotFound(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 0},
	}
	repo := NewProductRepository(mockDB)

	err := repo.DeleteProduct(context.Background(), 123)
	if err == nil {
		t.Fatal("DeleteProduct should have failed for non-existent product")
	}
	if !errors.Is(err, ErrProductNotFound) {
		t.Errorf("Expected product not found error, got: %v", err)
	}
}

func TestGetProductsByCategory_EmptyCategory(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	_, err := repo.GetProductsByCategory(context.Background(), "", 10, 0)
	if err == nil {
		t.Fatal("GetProductsByCategory should have failed with empty category")
	}
	if err.Error() != "category cannot be empty" {
		t.Errorf("Expected empty category error, got: %v", err)
	}
}

func TestGetProductsByBrand_EmptyBrand(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	_, err := repo.GetProductsByBrand(context.Background(), "", 10, 0)
	if err == nil {
		t.Fatal("GetProductsByBrand should have failed with empty brand")
	}
	if err.Error() != "brand cannot be empty" {
		t.Errorf("Expected empty brand error, got: %v", err)
	}
}

func TestSearchProducts_EmptyQuery(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	_, err := repo.SearchProducts(context.Background(), "", 10, 0)
	if err == nil {
		t.Fatal("SearchProducts should have failed with empty query")
	}
	if err.Error() != "search query cannot be empty" {
		t.Errorf("Expected empty query error, got: %v", err)
	}
}

func TestAddProductImage_ValidationError(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	// Image with invalid product ID should fail validation
	image := &ProductImage{
		ProductID:   -1,
		ImageURL:    "http://example.com/image.jpg",
		IsMain:      false,
		ImageOrder:  1,
		FileSize:    1024,
		ContentType: "image/jpeg",
	}

	err := repo.AddProductImage(context.Background(), image)
	if err == nil {
		t.Fatal("AddProductImage should have failed validation")
	}
	if !strings.Contains(err.Error(), "product ID is required and must be positive") {
		t.Errorf("Expected validation error, got: %v", err)
	}
}

func TestUpdateProductImage_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	image := &ProductImage{
		ID:          456,
		ProductID:   123,
		ImageURL:    "http://example.com/updated-image.jpg",
		IsMain:      true,
		ImageOrder:  1,
		FileSize:    2048,
		ContentType: "image/jpeg",
	}

	err := repo.UpdateProductImage(context.Background(), image)
	if err != nil {
		t.Fatalf("UpdateProductImage failed: %v", err)
	}
}

func TestUpdateProductImage_NotFound(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 0},
	}
	repo := NewProductRepository(mockDB)

	image := &ProductImage{
		ID:          456,
		ProductID:   123,
		ImageURL:    "http://example.com/updated-image.jpg",
		IsMain:      true,
		ImageOrder:  1,
		FileSize:    2048,
		ContentType: "image/jpeg",
	}

	err := repo.UpdateProductImage(context.Background(), image)
	if err == nil {
		t.Fatal("UpdateProductImage should have failed for non-existent image")
	}
	if !errors.Is(err, ErrProductImageNotFound) {
		t.Errorf("Expected product image not found error, got: %v", err)
	}
}

func TestDeleteProductImage_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	err := repo.DeleteProductImage(context.Background(), 456)
	if err != nil {
		t.Fatalf("DeleteProductImage failed: %v", err)
	}
}

func TestDeleteProductImage_NotFound(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 0},
	}
	repo := NewProductRepository(mockDB)

	err := repo.DeleteProductImage(context.Background(), 456)
	if err == nil {
		t.Fatal("DeleteProductImage should have failed for non-existent image")
	}
	if !errors.Is(err, ErrProductImageNotFound) {
		t.Errorf("Expected product image not found error, got: %v", err)
	}
}

func TestSetMainImage_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	err := repo.SetMainImage(context.Background(), 123, 456)
	if err != nil {
		t.Fatalf("SetMainImage failed: %v", err)
	}
}

func TestSetMainImage_ImageNotFound(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 0},
	}
	repo := NewProductRepository(mockDB)

	err := repo.SetMainImage(context.Background(), 123, 456)
	if err == nil {
		t.Fatal("SetMainImage should have failed for non-existent image")
	}
	if !errors.Is(err, ErrProductImageNotFound) {
		t.Errorf("Expected product image not found error, got: %v", err)
	}
}

func TestBulkInsertProducts_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	products := []*Product{
		{
			ID:           123,
			Name:         "Product 1",
			Description:  "Description 1",
			InitialPrice: 100.0,
			FinalPrice:   90.0,
			Currency:     "USD",
			InStock:      true,
			Category:     "Category 1",
			Brand:        "Brand 1",
		},
		{
			ID:           124,
			Name:         "Product 2",
			Description:  "Description 2",
			InitialPrice: 200.0,
			FinalPrice:   180.0,
			Currency:     "USD",
			InStock:      true,
			Category:     "Category 2",
			Brand:        "Brand 2",
		},
	}

	err := repo.BulkInsertProducts(context.Background(), products)
	if err != nil {
		t.Fatalf("BulkInsertProducts failed: %v", err)
	}
}

func TestBulkInsertProducts_EmptySlice(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	err := repo.BulkInsertProducts(context.Background(), []*Product{})
	if err != nil {
		t.Fatalf("BulkInsertProducts failed with empty slice: %v", err)
	}
}

func TestBulkInsertProductImages_Success(t *testing.T) {
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1},
	}
	repo := NewProductRepository(mockDB)

	images := []*ProductImage{
		{
			ProductID:   123,
			ImageURL:    "http://example.com/image1.jpg",
			IsMain:      true,
			ImageOrder:  1,
			FileSize:    1024,
			ContentType: "image/jpeg",
		},
		{
			ProductID:   123,
			ImageURL:    "http://example.com/image2.jpg",
			IsMain:      false,
			ImageOrder:  2,
			FileSize:    2048,
			ContentType: "image/jpeg",
		},
	}

	err := repo.BulkInsertProductImages(context.Background(), images)
	if err != nil {
		t.Fatalf("BulkInsertProductImages failed: %v", err)
	}
}

func TestBulkInsertProductImages_EmptySlice(t *testing.T) {
	mockDB := &mockDatabase{}
	repo := NewProductRepository(mockDB)

	err := repo.BulkInsertProductImages(context.Background(), []*ProductImage{})
	if err != nil {
		t.Fatalf("BulkInsertProductImages failed with empty slice: %v", err)
	}
}

func TestPrepareProductDefaults(t *testing.T) {
	repo := &productRepository{}

	product := &Product{
		ID:           123,
		Name:         "Test Product",
		Description:  "Test Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
	}

	repo.prepareProductDefaults(product)

	if product.CreatedAt.IsZero() {
		t.Error("CreatedAt should be set")
	}
	if product.UpdatedAt.IsZero() {
		t.Error("UpdatedAt should be set")
	}
	if product.Currency != "USD" {
		t.Errorf("Expected currency USD, got %s", product.Currency)
	}
	if !product.InStock {
		t.Error("InStock should default to true")
	}
}

func TestIsDuplicateError(t *testing.T) {
	tests := []struct {
		name     string
		err      error
		expected bool
	}{
		{
			name:     "nil error",
			err:      nil,
			expected: false,
		},
		{
			name:     "duplicate error",
			err:      errors.New("duplicate key value violates unique constraint"),
			expected: true,
		},
		{
			name:     "unique error",
			err:      errors.New("unique constraint violation"),
			expected: true,
		},
		{
			name:     "other error",
			err:      errors.New("some other error"),
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isDuplicateError(tt.err)
			if result != tt.expected {
				t.Errorf("isDuplicateError(%v) = %v, expected %v", tt.err, result, tt.expected)
			}
		})
	}
}

// TestProductEntityMethods tests the domain methods on Product entity
func TestProductEntityMethods(t *testing.T) {
	product := &Product{
		Name:         "Test Product",
		InitialPrice: 100.0,
		FinalPrice:   80.0,
		InStock:      true,
		MainImage:    "http://example.com/main.jpg",
		Images: []ProductImage{
			{ImageURL: "http://example.com/main.jpg", IsMain: true},
			{ImageURL: "http://example.com/thumb.jpg", IsMain: false},
		},
	}

	// Test IsOnSale
	if !product.IsOnSale() {
		t.Error("Product should be on sale")
	}

	// Test DiscountPercentage
	discount := product.DiscountPercentage()
	expectedDiscount := 20.0
	if discount != expectedDiscount {
		t.Errorf("Expected discount %.2f%%, got %.2f%%", expectedDiscount, discount)
	}

	// Test FormattedPrice
	formatted := product.FormattedPrice()
	expected := "80.00 USD"
	if formatted != expected {
		t.Errorf("Expected formatted price %s, got %s", expected, formatted)
	}

	// Test HasImages
	if !product.HasImages() {
		t.Error("Product should have images")
	}

	// Test GetMainImage
	mainImage := product.GetMainImage()
	expectedImage := "http://example.com/main.jpg"
	if mainImage != expectedImage {
		t.Errorf("Expected main image %s, got %s", expectedImage, mainImage)
	}

	// Test IsAvailable
	if !product.IsAvailable() {
		t.Error("Product should be available")
	}

	// Test GetDisplayName
	displayName := product.GetDisplayName()
	expectedName := "Test Product"
	if displayName != expectedName {
		t.Errorf("Expected display name %s, got %s", expectedName, displayName)
	}
}

// TestProductImageEntityMethods tests the domain methods on ProductImage entity
func TestProductImageEntityMethods(t *testing.T) {
	image := &ProductImage{
		ImageURL:    "http://example.com/image.jpg",
		ContentType: "image/jpeg",
		FileSize:    1024,
	}

	// Test IsImage
	if !image.IsImage() {
		t.Error("Image should be identified as image")
	}

	// Test FormattedFileSize
	formatted := image.FormattedFileSize()
	if formatted != "1.0 KB" {
		t.Errorf("Expected formatted file size '1.0 KB', got %s", formatted)
	}

	// Test GetFileExtension
	ext := image.GetFileExtension()
	if ext != ".jpg" {
		t.Errorf("Expected file extension '.jpg', got %s", ext)
	}
}

// TestProductJSON_OtherAttributes_Integration tests JSON scanning functionality for OtherAttributes field
func TestProductJSON_OtherAttributes_Integration(t *testing.T) {
	// Skip if no database URL is available
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		t.Skip("Skipping integration test, DATABASE_URL not set")
	}

	// Setup test database
	db, err := database.NewPostgreSQLClient(dbURL)
	if err != nil {
		t.Fatalf("Failed to create database client: %v", err)
	}
	defer func() { _ = db.Close() }()

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := db.Connect(ctx); err != nil {
		t.Skipf("Skipping test, database not available: %v", err)
	}

	// Create test table with JSONB column
	_, err = db.Exec(ctx, `
		CREATE TEMP TABLE test_product_json (
			id SERIAL PRIMARY KEY,
			name TEXT NOT NULL,
			other_attributes JSONB
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create test table: %v", err)
	}

	// Test data with image metadata
	imageMetadata := map[string]interface{}{
		"images": []map[string]interface{}{
			{
				"filename":     "product-123-main.jpg",
				"width":        800,
				"height":       600,
				"size_bytes":   245760,
				"content_type": "image/jpeg",
				"uploaded_at":  "2024-01-15T10:30:00Z",
				"minio_key":    "products/123/main.jpg",
			},
			{
				"filename":     "product-123-thumb.jpg",
				"width":        200,
				"height":       150,
				"size_bytes":   15360,
				"content_type": "image/jpeg",
				"uploaded_at":  "2024-01-15T10:30:05Z",
				"minio_key":    "products/123/thumb.jpg",
			},
		},
		"processing_status": "completed",
		"total_images":      2,
		"last_updated":      "2024-01-15T10:30:05Z",
	}

	// Create product with OtherAttributes
	product := &Product{
		ID:   123,
		Name: "Test Product with JSON Metadata",
	}
	if err := product.SetOtherAttributesJSON(imageMetadata); err != nil {
		t.Fatalf("Failed to set OtherAttributes JSON: %v", err)
	}

	// Insert product using raw SQL to test JSONB functionality
	_, err = db.Exec(ctx, `
		INSERT INTO test_product_json (id, name, other_attributes)
		VALUES ($1, $2, $3)
	`, product.ID, product.Name, product.OtherAttributes)
	if err != nil {
		t.Fatalf("Failed to insert product: %v", err)
	}

	// Retrieve product and verify JSON data
	row := db.QueryRow(ctx, `
		SELECT id, name, other_attributes
		FROM test_product_json
		WHERE id = $1
	`, product.ID)

	var retrievedID int64
	var retrievedName string
	var retrievedOtherAttributes string

	err = row.Scan(&retrievedID, &retrievedName, &retrievedOtherAttributes)
	if err != nil {
		t.Fatalf("Failed to scan retrieved product: %v", err)
	}

	// Verify basic fields
	if retrievedID != product.ID {
		t.Errorf("Retrieved ID = %d, want %d", retrievedID, product.ID)
	}
	if retrievedName != product.Name {
		t.Errorf("Retrieved Name = %s, want %s", retrievedName, product.Name)
	}

	// Create a product with the retrieved OtherAttributes string
	retrievedProduct := &Product{
		ID:              retrievedID,
		Name:            retrievedName,
		OtherAttributes: retrievedOtherAttributes,
	}

	// Verify JSON data was properly stored and retrieved
	retrievedData, err := retrievedProduct.GetOtherAttributesJSON()
	if err != nil {
		t.Fatalf("Failed to get OtherAttributes JSON: %v", err)
	}
	if retrievedData == nil {
		t.Fatal("Retrieved OtherAttributes data is nil")
	}

	retrievedDataMap, ok := retrievedData.(map[string]interface{})
	if !ok {
		t.Fatalf("Retrieved OtherAttributes data is not a map, got %T", retrievedData)
	}

	// Verify image metadata structure
	images, ok := retrievedDataMap["images"].([]interface{})
	if !ok {
		t.Fatal("Images field is not a slice")
	}
	if len(images) != 2 {
		t.Errorf("Expected 2 images, got %d", len(images))
	}

	// Verify first image metadata
	firstImage, ok := images[0].(map[string]interface{})
	if !ok {
		t.Fatal("First image is not a map")
	}
	if firstImage["filename"] != "product-123-main.jpg" {
		t.Errorf("First image filename = %v, want 'product-123-main.jpg'", firstImage["filename"])
	}
	if firstImage["width"] != float64(800) {
		t.Errorf("First image width = %v, want 800", firstImage["width"])
	}
	if firstImage["size_bytes"] != float64(245760) {
		t.Errorf("First image size_bytes = %v, want 245760", firstImage["size_bytes"])
	}

	// Verify processing status
	if retrievedDataMap["processing_status"] != "completed" {
		t.Errorf("Processing status = %v, want 'completed'", retrievedDataMap["processing_status"])
	}
	if retrievedDataMap["total_images"] != float64(2) {
		t.Errorf("Total images = %v, want 2", retrievedDataMap["total_images"])
	}

	t.Log("JSON scanning and storage test passed - image metadata properly saved and retrieved")
}

// TestTransactionRollbackBehavior verifies that rollback is not called after successful commit
func TestTransactionRollbackBehavior(t *testing.T) {
	// Create a mock database that tracks transaction calls
	mockDB := &mockDatabase{
		execResult: &mockResult{rowsAffected: 1, lastInsertID: 123},
	}

	// Create a mock transaction that tracks calls
	mockTx := &mockTx{
		execResult: &mockResult{rowsAffected: 1, lastInsertID: 123},
	}

	// Override BeginTx to return our tracked transaction
	mockDB.beginTxFunc = func(ctx context.Context, opts *sql.TxOptions) (database.Tx, error) {
		return mockTx, nil
	}

	repo := NewProductRepository(mockDB)

	// Create a valid product
	product := &Product{
		ID:           123,
		Name:         "Test Product",
		Description:  "Test Description",
		InitialPrice: 100.0,
		FinalPrice:   90.0,
		Currency:     "USD",
		InStock:      true,
		Category:     "Test",
		Brand:        "Test Brand",
	}

	// Insert product (this should commit successfully)
	err := repo.InsertProduct(context.Background(), product)
	if err != nil {
		t.Fatalf("Failed to insert product: %v", err)
	}

	// Verify that commit was called
	if !mockTx.commitCalled {
		t.Error("Expected commit to be called, but it wasn't")
	}

	// Verify that rollback was NOT called (since commit succeeded)
	if mockTx.rollbackCalled {
		t.Error("Rollback was called after successful commit - this indicates the transaction rollback bug")
	}

	t.Log("Transaction rollback behavior test passed - rollback not called after successful commit")
}
